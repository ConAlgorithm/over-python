### 面向对象
小伙伴们应该都听过“面向对象编程”一词，也经常有人问什么是“面向对象编程”，我们先来看看比较正式的说法。

把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，
通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。

### 类和对象
简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。
当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。

我们用以下方式定义一个类。

    class nameoftheclass(parent_class):
        statement1
        statement2
        statement3
在语句中你可以编写任何Python语句，你可以定义函数（我们称之为类的方法）。

    >>> class MyClass(object):
    ...     a = 90
    ...     b = 88
    ...
    >>> p = MyClass()
    >>> p
    <__main__.MyClass instance at 0xb7c8aa6c>
在上面的例子中，您可以看到我们首先声明一个名为MyClass的类，在该类中编写一些随机语句。在类定义之后，我们创建了一个MyClass 类的对象 p 。
如果你做了一个目录

    >>> dir(p)
    ['__doc__', '__module__', 'a', 'b']
    你可以在里面看到变量a和b。

#### __init__方法
__init__是Python类中的一种特殊方法，它是类的构造方法。在以下示例中，您可以看到如何使用它。

    class Student(object):
        """
        Returns a ```Student``` object with the given name, branch and year.

        """
        def __init__(self, name, branch, year):
                self.name = name
                self.branch = branch
                self.year = year
                print("A student object is created.")

        def print_details(self):
            """
            Prints the details of the student.
            """
            print("Name:", self.name)
            print("Branch:", self.branch)
            print("Year:", self.year)
在构造类的对象时调用__init__。这意味着当我们创建学生对象时，我们将在提示中看到消息“创建学生对象”。您可以看到该方法的第一个参数是self。它是一个指向当前对象的特殊变量（在C ++中就是这样）。该对象被隐式传递给它中可用的每个方法，但我们必须在编写方法时在每个方法中明确地获取它。示例如下所示。请记住在__init__方法本身中声明所有可能的属性。即使您没有立即使用它们，也可以将它们分配为无。

      >>> std1 = Student()
      Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      TypeError: __init__() takes exactly 4 arguments (1 given)
      >>> std1 = Student('Kushal','CSE','2005')
      A student object is created
在这个例子中，我们首先尝试创建一个Student对象而不传递任何参数，Python解释器抱怨它只需要4个参数但只收到一个（self）。然后我们创建了一个具有适当参数值的对象，并且从打印的消息中，可以很容易地理解__init__方法被称为构造方法。

现在我们将调用print_details（）方法。

      >>> std1.print_details()
      Name: Kushal
      Branch: CSE
      Year: 2005
#### 继承
一般来说，我们人类总是知道遗产。在编程中它几乎是一样的。当一个类继承另一个类时，它继承了父类的所有特性（如变量和方法）。这有助于重用代码。

在下一个示例中，我们首先创建一个名为Person的类，并创建两个子类Student和Teacher。由于这两个类都是从Person类继承的，因此它们将具有Person的所有方法，并且为了自己的目的将具有新的方法和变量。

      student_teacher.py 
      #!/usr/bin/env python3

      class Person(object):
          """
          Returns a ```Person``` object with given name.

          """
          def __init__(self, name):
              self.name = name

          def get_details(self):
              "Returns a string containing name of the person"
              return self.name


      class Student(Person):
          """
          Returns a ```Student``` object, takes 3 arguments, name, branch, year.

          """
          def __init__(self, name, branch, year):
              Person.__init__(self, name)
              self.branch = branch
              self.year = year

          def get_details(self):
              "Returns a string containing student's details."
              return "%s studies %s and is in %s year." % (self.name, self.branch, self.year)


      class Teacher(Person):
          """
          Returns a ```Teacher``` object, takes a list of strings (list of papers) as
          argument.
          """
          def __init__(self, name, papers):
              Person.__init__(self, name)
              self.papers = papers

          def get_details(self):
              return "%s teaches %s" % (self.name, ','.join(self.papers))


      person1 = Person('Sachin')
      student1 = Student('Kushal', 'CSE', 2005)
      teacher1 = Teacher('Prashad', ['C', 'C++'])

      print(person1.get_details())
      print(student1.get_details())
      print(teacher1.get_details())
输出：

      $ ./student_teacher.py
      Sachin
      Kushal studies CSE and is in 2005 year.
      Prashad teaches C,C++
在这个例子中，您可以看到我们如何在Student和Teacher类的__init__方法中调用类Person的__init__方法。我们还在Student和Teacher类中重新实现了Person类的get_details（）方法。因此，当我们在teacher1对象上调用get_details（）方法时，它会根据对象本身（属于教师类）返回，当我们在student1或person1对象上调用get_details（）时，它会根据实现的get_details（）方法返回在它自己的班级。

#### 多重继承
一个类可以继承多个类。它可以访问父类的所有方法和变量。一般语法是：

      class MyClass(Parentclass1, Parentclass2,...):
          def __init__(self):
              Parentclass1.__init__(self)
              Parentclass2.__init__(self)
              ...
              ...
删除对象
由于我们已经知道如何创建对象，现在我们将看到如何删除Python对象。我们为此使用del。

      >>> s = "I love you"
      >>> del s
      >>> s
      Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      NameError: name 's' is not defined
del实际上减少了一个引用计数。当对象的引用计数变为零时，垃圾收集器将删除该对象。

#### Python中的getter和
一个简单的答案，不要。如果您来自其他语言（阅读Java），您将很想在所有课程中使用getter或setter。请不要。只需直接使用属性即可。以下是直接示例。

      >>> class Student(object):
      ...     def __init__(self, name):
      ...         self.name = name
      ...
      >>> std = Student("Kushal Das")
      >>> print(std.name)
      Kushal Das
      >>> std.name = "Python"
      >>> print(std.name)
      Python
##### 属性
如果您希望对数据属性访问进行更精细的控制，则可以使用属性。在下面的银行账户示例中，我们将确保没有人可以将货币值设置为负值，并且名为inr的属性将为我们提供账户中美元的INR值。

      #!/usr/bin/env python3

      class Account(object):
          """The Account class,
          The amount is in dollars.
          """
          def __init__(self, rate):
              self.__amt = 0
              self.rate = rate

          @property
          def amount(self):
              "The amount of money in the account"
              return self.__amt

          @property
          def inr(self):
              "Gives the money in INR value."
              return self.__amt * self.rate

          @amount.setter
          def amount(self, value):
              if value < 0:
                  print("Sorry, no negative amount in the account.")
                  return
              self.__amt = value

      if __name__ == '__main__':
          acc = Account(rate=61) # Based on today's value of INR :(
          acc.amount = 20
          print("Dollar amount:", acc.amount)
          print("In INR:", acc.inr)
          acc.amount = -100
          print("Dollar amount:", acc.amount)
输出：

      $ python property.py
      Dollar amount: 20
      In INR: 1220
      Sorry, no negative amount in the account.
      Dollar amount: 20
